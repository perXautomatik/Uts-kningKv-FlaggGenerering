/*
 we correct adresses from visoin or other external source,
 * after testing vision > fir we concluded that old enteries in vision <fir
* therefore it's important to see the date of the matching entry, and if it is to old, swap with latest fir

 we expect theese possible states
    1 complete, no correction required * and matching latest fir
    2 compete but not matching * where fir date is rely old for example
    3 complete and matching, with aditional entries in fir
    4 incomplete but matching eather with or without aditional entries
    5 incomplete and not matching.
    6* matching vision but date older than fir non matching

we expect the function to return thees ressult accordingly

    1. input
    2. input
    3. input U fir where match is made

    this can all be expressed with a single outerjoin

    4. fir U fir
    5. rest ressult as sepparate select vision X fir

 it's important that fir does not overwrite info if it exsists and we will therefore in the reparationprocess
 figure outhow to procede
 do we do branching, case broken state one, select fir col1 and vision col rest otherwire othercolumns.
            -- kan möjligen vara så att postnummret är iopslaget med andra isåfall ta fir corrikering
           -- vision adressen har dock fältbegränsning, thatis, kanske aldrig fel i postnret, men i annat fält
           -- problem is that we need the whole kit, we can't just take on part from one side and then
           -- the rest from the other side, rather we should check, if any of this falls true, then take all from one side

 --if anny of the correcting is null, compare, then if equal, pick first
                 -- we'll use a pointsystem to determen which side is best
                 --or nullif(FirCorrection.adress, possiblyNull.Gatuadress, possiblyNull.Postnummer, ',',possiblyNull.Postor, ',', FirCorrection.postnr, ',', FirCorrection.FAL_POSTORT)
 */